import csv
import pandas as pd
import numpy as np
from keras.preprocessing.sequence import pad_sequences

def read_data_file(data_file_path):
    with open(data_file_path, 'rU') as f:
        data = list(list(map(lambda x: int(x), row)) for row in csv.reader(f, delimiter=','))

    return data


def extract_header(in_file_path, skip_flag, max_pe_len=352, max_sec_len=3552):
    BASE = 0
    DOS_HEADER_LEN = 64
    DOS_STUB_LEN = 14

    DOS_header = []
    PE_header = []
    Sec_header = []

    raw_data = read_data_file(in_file_path)

    short_index = []
    index = -1

    for i in raw_data:
        index += 1
        # Remove data smaller than 97 bytes, not a PE file
        if(skip_flag and len(i)<97):
            print('Too short data with length: ', len(i),  ' index is: ', index, '  .... skipping......')
            short_index.append(index)
            continue
        # 0 - 78 fixed length
        temp_DOS = i[BASE:DOS_HEADER_LEN+DOS_STUB_LEN]
        temp_DOS_1 = [x+1 for x in temp_DOS]
        DOS_header.append(temp_DOS_1)

        # Locate PE Pointer in DOS header (60, 61, 62, 63)
        PE_pointer = temp_DOS[DOS_HEADER_LEN-4:DOS_HEADER_LEN]
        # print('PE_pointer ', PE_pointer)
        PE_header_offset = PE_pointer[0]+PE_pointer[1]*256+PE_pointer[2]*(256**2)+PE_pointer[3]*(256**3)
        # print('PE_header_offset ', PE_header_offset)

        # Locate PE Header section by PE Header offset
        PE_signature = i[PE_header_offset: PE_header_offset+4]
        PE_file_header = i[PE_header_offset+4:PE_header_offset+24]

        # Locate Section Header number in PE file header and calculate section header length
        Sec_num_pointer = PE_file_header[2:4]
        # print(Sec_num_pointer)
        Sec_num = Sec_num_pointer[0]*256+Sec_num_pointer[1]
        Sec_header_len = Sec_num*40

        # Locate Optional header length in PE file header
        Opt_header_hex = PE_file_header[16:18]
        Opt_header_len = Opt_header_hex[0]+Opt_header_hex[1]*256

        # Calculate Section Header offset by PE header length
        Sec_header_offset = PE_header_offset+24+Opt_header_len

        # Get PE optional header by PE_header offset
        PE_opt_header = i[PE_header_offset+24: Sec_header_offset]

        # Concatenate PE sigature, PE file header and PE optional header
        temp_PE = list()
        temp_PE.extend(PE_signature)
        temp_PE.extend(PE_file_header)
        temp_PE.extend(PE_opt_header)
        
        temp_PE_1 = [x+1 for x in temp_PE]
        # print('temp_PE ', temp_PE)
        PE_header.append(temp_PE_1)

        temp_Sec_header = i[Sec_header_offset: Sec_header_offset+Sec_header_len]

        # truncate section header, only take the first 40bit
        trunc_sec_header = []
        for j in range(Sec_num):
            trunc_sec_header.extend(temp_Sec_header[j*40: j*40+12])
        trunc_sec_header_1 = [x+1 for x in trunc_sec_header] 
        Sec_header.append(trunc_sec_header_1)


    PE_header_pad = pad_sequences(PE_header, maxlen=max_pe_len, dtype='int32', padding='post', truncating='post')
    Sec_header_pad = pad_sequences(Sec_header, maxlen=max_sec_len, dtype='int32', padding='post', truncating='post')

    full_header = np.concatenate((DOS_header, PE_header_pad, Sec_header_pad), axis=1)
    output = pd.DataFrame(data=full_header)

    print('PE_header_max_len: ', max_pe_len)
    print('Sec_header_max_len: ', max_sec_len)

    return output, short_index


def read_label_file(label_file_path):
    df = pd.read_csv(label_file_path, sep=',', header=0, usecols=['category'])
    return df.values
