import csv
import pandas as pd
import numpy as np
from keras.preprocessing.sequence import pad_sequences

def read_data_file(data_file_path):
    with open(data_file_path, 'rU') as f:
        data = list(list(map(lambda x: int(x), row)) for row in csv.reader(f, delimiter=','))

    return data

def read_label_file(label_file_path):
    df = pd.read_csv(label_file_path, sep=',', header=0, usecols=['category'])
    return df.values

def extract_label(in_file_path, out_file_path, short_index):
    y = read_label_file(in_file_path)
    output = pd.DataFrame(data=y)
    output.drop(short_index, axis=0)
    output.to_csv(out_file_path, index=False, header=False)

def extract_header(in_file_path, out_file_path, skip_flag=True):
    BASE = 0
    DOS_HEADER_LEN = 64
    DOS_STUB_LEN = 14
    PE_SIG_LEN=4

    DOS_header = []
    PE_header = []
    Sec_header = []

    PE_header_max_len = 0
    Sec_header_max_len = 0

    raw_data = read_data_file(in_file_path)

    short_index = []
    index = -1
    print('data processing started ...')
    for i in raw_data:
        index += 1
        # Remove data smaller than 97 bytes, not a PE file
        if(skip_flag and len(i)<97):
            print('Too short data with length: ', len(i),  ' index is: ', index, '  .... skipping......')
            short_index.append(index)
            continue
        # 0 - 78 fixed length
        temp_DOS = i[BASE:DOS_HEADER_LEN+DOS_STUB_LEN]
        DOS_header.append(temp_DOS)

        # Locate PE Pointer in DOS header (60, 61, 62, 63)
        PE_pointer = temp_DOS[DOS_HEADER_LEN-4:DOS_HEADER_LEN]
        # print('PE_pointer ', PE_pointer)
        PE_header_offset = PE_pointer[0]+PE_pointer[1]*256+PE_pointer[2]*(256**2)+PE_pointer[3]*(256**3)
        # print('PE_header_offset ', PE_header_offset)

        # Locate PE Header section by PE Header offset
        PE_signature = i[PE_header_offset: PE_header_offset+4]
        PE_file_header = i[PE_header_offset+4:PE_header_offset+24]

        # Locate Section Header number in PE file header and calculate section header length
        Sec_num_pointer = PE_file_header[2:4]
        # print(Sec_num_pointer)
        Sec_num = Sec_num_pointer[0]*256+Sec_num_pointer[1]
        Sec_header_len = Sec_num*40

        # Locate Optional header length in PE file header
        Opt_header_hex = PE_file_header[16:18]
        Opt_header_len = Opt_header_hex[0]+Opt_header_hex[1]*256

        # Calculate Section Header offset by PE header length
        Sec_header_offset = PE_header_offset+24+Opt_header_len

        # Get PE optional header by PE_header offset
        PE_opt_header = i[PE_header_offset+24: Sec_header_offset]

        # Concatenate PE sigature, PE file header and PE optional header
        temp_PE = list()
        temp_PE.extend(PE_signature)
        temp_PE.extend(PE_file_header)
        temp_PE.extend(PE_opt_header)
        # print('temp_PE ', temp_PE)
        PE_header.append(temp_PE)

        if(len(temp_PE) == 24+Opt_header_len):
            # print("PE Header is correctly cut")
            if(len(temp_PE)>PE_header_max_len):
                PE_header_max_len = len(temp_PE)
        temp_Sec_header = i[Sec_header_offset: Sec_header_offset+Sec_header_len]

        # truncate section header, only take the first 40bit
        trunc_sec_header = []
        for j in range(Sec_num):
            trunc_sec_header.extend(temp_Sec_header[j*40: j*40+5])
        Sec_header.append(trunc_sec_header)

        if(len(trunc_sec_header)>Sec_header_max_len):
                Sec_header_max_len = len(trunc_sec_header)


    PE_header_pad = pad_sequences(PE_header, maxlen=PE_header_max_len, dtype='int32', padding='post', truncating='post')
    Sec_header_pad = pad_sequences(Sec_header, maxlen=Sec_header_max_len, dtype='int32', padding='post', truncating='post')

    full_header = np.concatenate((DOS_header, PE_header_pad, Sec_header_pad), axis=1)
    output = pd.DataFrame(data=full_header)

    print('PE_header_max_len: ', PE_header_max_len)
    print('Sec_header_max_len: ', Sec_header_max_len)
    print("saving extracted data to file... with shape: ", output.shape)
    output.to_csv(out_file_path, index=False, header=False)

    return short_index

print("Extract train.csv ")
short_index = extract_header("./Data/train/train.csv", "./Data/train/train_extract.csv", skip_flag=True)
#
# print("update train_label.csv")
# extract_label("./Data/train/train_label.csv", "./Data/train/train_label_extract.csv", [71446])

print("Extract test.csv ")
extract_header("./Data/test/test.csv", "./Data/test/test_extract.csv", skip_flag=False)
